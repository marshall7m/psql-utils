load "${BATS_TEST_DIRNAME}/../load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bash-utils/load.bash"

load "${BATS_TEST_DIRNAME}/../node_modules/bats-support/load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bats-assert/load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bats-utils/load.bash"

setup_file() {
    load 'common_setup.bash'

    _common_setup
    export script_logging_level="DEBUG"
    
    log "FUNCNAME=$FUNCNAME" "DEBUG"
}

teardown_file() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"
    teardown_test_file_tmp_dir
}

setup() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"

    export table="table_$BATS_TEST_NUMBER"
    # run_only_test 11
}

teardown() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"

    teardown_test_case_tmp_dir

    psql -c "DROP TABLE IF EXISTS $table CASCADE;"
}

@test "Script is runnable" {
    run jq_to_psql_records.bash
}

@test "invalid jq input" {
    in="foo"
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_failure
}

@test "returns parsable jq output" {
    in=$(jq -n '
    [
        {
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    out=$(jq_to_psql_records.bash --jq-input "$in" --table "$table")

    log "Out:" "DEBUG"
    log "$out" "DEBUG"

    echo "$out" | jq '.'
    [ "$?" -eq 0 ]
}

@test "jq object with array value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": ["daz", "zaz"]
    }
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success
}


@test "jq array with array value" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": ["daz", "zaz"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    

    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success
}

@test "jq object with empty array value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": []
    }
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_failure

    assert_output -p "Detected no data type"
}

@test "jq object with empty array value and type map arg" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": []
    }
    ')
    
    type_map=$(jq -n '{"baz": "TEXT[]"}')
    run jq_to_psql_records.bash --jq-input "$in" --table "$table" --type-map "$type_map"
    assert_success

    assert_output -p "foo VARCHAR, baz TEXT[]"
}

@test "jq object with null value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": null
    }
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success
}


@test "jq array with empty array value" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": []
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    

    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success

}

@test "jq array with empty array value and type map arg" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": []
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    type_map=$(jq -n '
    {
        "foo": "VARCHAR"
    }
    ')

    run jq_to_psql_records.bash --jq-input "$in" --table "$table" --type-map "$type_map"

    psql -c "SELECT * FROM $table;"

    assert_success
    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"
}


@test "Insert jq array into pre-existing table with unbalanced identity column values" {
    # unbalanced meaning some identity values are null, which will violate not-null constraint
    # when csv form of jq input is `COPY` into staging table
    psql -q -c """
    CREATE TABLE $table (
        id INT GENERATED ALWAYS AS IDENTITY,
        second_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 10 INCREMENT BY 10),
        foo VARCHAR,
        baz TEXT[]
    );
    INSERT INTO $table (foo, baz) VALUES('cee', ARRAY['bee']);
    """

    in=$(jq -n '
    [
        {
            "id": 2,
            "foo": "bar",
            "baz": ["dar", "zar"]
        },
        {
            "second_id": 30,
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    log "$(psql -c "SELECT * FROM $table")" "DEBUG"

    assert_failure
    
    log "Assert inserted identity column values are incremented properly" "DEBUG"
    run psql -c """
    DO \$\$
    BEGIN
        ASSERT (
            SELECT COUNT(*)
            FROM (
                SELECT DISTINCT id
                FROM $table
            ) AS temp
        ) = 1;
    END;
    \$\$ LANGUAGE plpgsql;
    """
    assert_success
}

@test "Insert jq array into pre-existing table with identity columns" {
    psql -q -c """
    CREATE TABLE $table (
        id INT GENERATED ALWAYS AS IDENTITY,
        second_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 10 INCREMENT BY 10),
        foo VARCHAR,
        baz TEXT[]
    );
    INSERT INTO $table (foo, baz) VALUES('cee', ARRAY['bee']);
    """

    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    log "$(psql -c "SELECT * FROM $table")" "DEBUG"

    assert_success
    
    run psql -c """
    DO \$\$
        BEGIN
            RAISE NOTICE 'Assert all rows were inserted';
            ASSERT (
                SELECT COUNT(*)
                FROM $table
            ) = 3;

            RAISE NOTICE 'Assert inserted identity column values are incremented properly';
            ASSERT (
                SELECT last_value
                FROM ${table}_id_seq
            ) = 3;
            ASSERT (
                SELECT last_value
                FROM ${table}_second_id_seq
            ) = 30;
        END;
    \$\$ LANGUAGE plpgsql;
    """
    assert_success
}

@test "Insert jq array with null primary key value into pre-existing table with null primary key trigger handling" {
    psql -q -c """
    CREATE TABLE $table (foo VARCHAR PRIMARY KEY, baz TEXT[]);
    INSERT INTO $table VALUES('cee', ARRAY['bee']);
    
    CREATE OR REPLACE FUNCTION ${table}_defaults()
        RETURNS trigger
        LANGUAGE plpgsql AS \$\$
            BEGIN
                IF NEW.foo IS NULL THEN
                    NEW.foo := 'test-' || substr(md5(random()::text), 0, 18);
                END IF;
                RETURN NEW;
            END;
        \$\$;

    DROP TRIGGER IF EXISTS trig_${table}_defaults ON public.$table; 
    CREATE TRIGGER trig_${table}_defaults
        BEFORE INSERT ON $table
        FOR EACH ROW
        WHEN (
            NEW.foo IS NULL
        )
        EXECUTE PROCEDURE ${table}_defaults();
    
    DROP TRIGGER IF EXISTS trig_${table}_dummy ON public.$table; 
    CREATE TRIGGER trig_${table}_dummy
        BEFORE INSERT ON $table
        FOR EACH ROW
        WHEN (
            NEW.foo != NEW.foo
        )
        EXECUTE PROCEDURE ${table}_defaults();
    """

    in=$(jq -n '
    [
        {
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    psql -c "SELECT * FROM $table"

    assert_success

    run psql -c """
    DO \$\$
        BEGIN 
            ASSERT (
                SELECT COUNT(*)
                FROM $table
                WHERE foo IS NOT NULL
            ) = 3;
        END;
    \$\$
    """
    assert_success
}