load "${BATS_TEST_DIRNAME}/../load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bash-utils/load.bash"

load "${BATS_TEST_DIRNAME}/../node_modules/bats-support/load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bats-assert/load.bash"
load "${BATS_TEST_DIRNAME}/../node_modules/bats-utils/load.bash"

setup_file() {
    load 'common_setup.bash'

    _common_setup
    export script_logging_level="DEBUG"
    
    log "FUNCNAME=$FUNCNAME" "DEBUG"
}

teardown_file() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"
    teardown_test_file_tmp_dir
}

setup() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"

    export table="table_$BATS_TEST_NUMBER"
    # run_only_test 1
}

teardown() {
    log "FUNCNAME=$FUNCNAME" "DEBUG"

    teardown_test_case_tmp_dir

    psql -c "DROP TABLE IF EXISTS $table;"
}

@test "Insert jq array into pre-existing table with trigger" {

    trigger_name="${table}_default"
    trig_func="${table}_default_func"
    psql -q -c """
    CREATE TABLE $table (foo VARCHAR, baz TEXT[]);

    CREATE OR REPLACE FUNCTION $trig_func() RETURNS trigger LANGUAGE plpgsql AS \$\$
        BEGIN
            IF NEW.foo IS NULL THEN
                NEW.foo := 'DEFAULT';
            END IF;
            RETURN NEW;
        END;
    \$\$;

    CREATE TRIGGER $trigger_name
    BEFORE INSERT ON $table
    FOR EACH ROW
    WHEN (
        NEW.foo IS NULL
    )
    EXECUTE PROCEDURE $trig_func();

    INSERT INTO $table VALUES('cee', ARRAY['bee']);
    """

    in=$(jq -n '
    [
        {
            "foo": null,
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    psql -c "SELECT * FROM $table"
    assert_success
}

@test "Script is runnable" {
    run jq_to_psql_records.bash
}

@test "invalid jq input" {
    in="foo"
    table="table_$BATS_TEST_NUMBER"
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_failure
}

@test "jq object with array value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": ["daz", "zaz"]
    }
    ')
    table="table_$BATS_TEST_NUMBER"
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success
}


@test "jq array with array value" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": ["daz", "zaz"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    table="table_$BATS_TEST_NUMBER"

    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success
}

@test "jq object with empty array value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": []
    }
    ')
    table="table_$BATS_TEST_NUMBER"
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_failure

    assert_output -p "Detected no data type"
}

@test "jq object with empty array value and type map arg" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": []
    }
    ')
    table="table_$BATS_TEST_NUMBER"
    type_map=$(jq -n '{"baz": "TEXT[]"}')
    run jq_to_psql_records.bash --jq-input "$in" --table "$table" --type-map "$type_map"
    assert_success

    assert_output -p "foo VARCHAR, baz TEXT[]"
}

@test "jq object with null value" {
    in=$(jq -n '
    {
        "foo": "bar",
        "baz": null
    }
    ')
    table="table_$BATS_TEST_NUMBER"
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success
}


@test "jq array with empty array value" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": []
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    table="table_$BATS_TEST_NUMBER"

    run jq_to_psql_records.bash --jq-input "$in" --table "$table"
    assert_success

    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"

    run psql -c "SELECT * FROM $table;"
    assert_success

}

@test "jq array with empty array value and type map arg" {
    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": []
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    type_map=$(jq -n '
    {
        "foo": "VARCHAR"
    }
    ')

    run jq_to_psql_records.bash --jq-input "$in" --table "$table" --type-map "$type_map"

    psql -c "SELECT * FROM $table;"

    assert_success
    assert_output -p "Column types: foo VARCHAR, baz TEXT[]"
}


@test "Insert jq array into pre-existing table with identity column" {
    psql -q -c """
    CREATE TABLE $table (
        id INT GENERATED BY DEFAULT AS IDENTITY,
        second_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 10 INCREMENT BY 10),
        foo VARCHAR,
        baz TEXT[]
    );
    INSERT INTO $table VALUES(1, 10, 'cee', ARRAY['bee']);
    """

    in=$(jq -n '
    [
        {
            "foo": "bar",
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    log "$(psql -c "SELECT * FROM $table")" "DEBUG"

    assert_success
    
    log "Assert inserted identity column values are incremented properly" "DEBUG"
    run psql -c """
    DO \$\$
    BEGIN
        ASSERT (
            SELECT COUNT(*)
            FROM (
                SELECT DISTINCT id
                FROM $table
            ) AS temp
        ) = 3;
    END;
    \$\$ LANGUAGE plpgsql;
    """
    assert_success

}

@test "Insert jq array with null primary key value into pre-existing table with null primary key trigger handling" {
    psql -q -c """
    CREATE TABLE $table (foo VARCHAR PRIMARY KEY, baz TEXT[]);
    INSERT INTO $table VALUES('cee', ARRAY['bee']);
    
    CREATE OR REPLACE FUNCTION ${table}_defaults()
        RETURNS trigger
        LANGUAGE plpgsql AS \$\$
            BEGIN
                IF NEW.foo IS NULL THEN
                    NEW.foo := 'test-' || substr(md5(random()::text), 0, 18);
                END IF;
                RETURN NEW;
            END;
        \$\$;

    DROP TRIGGER IF EXISTS trig_${table}_defaults ON public.$table; 
    CREATE TRIGGER trig_${table}_defaults
        BEFORE INSERT ON $table
        FOR EACH ROW
        WHEN (
            NEW.foo IS NULL
        )
        EXECUTE PROCEDURE ${table}_defaults();
    
    DROP TRIGGER IF EXISTS trig_${table}_dummy ON public.$table; 
    CREATE TRIGGER trig_${table}_dummy
        BEFORE INSERT ON $table
        FOR EACH ROW
        WHEN (
            NEW.foo != NEW.foo
        )
        EXECUTE PROCEDURE ${table}_defaults();
    """

    in=$(jq -n '
    [
        {
            "baz": ["dar", "zar"]
        },
        {
            "foo": "nar",
            "baz": ["doo", "zoo"]
        }
    ]
    ')
    
    run jq_to_psql_records.bash --jq-input "$in" --table "$table"

    log "Updated table:" "DEBUG"
    psql -c "SELECT * FROM $table"

    assert_success

    run psql -c """
    DO \$\$
        BEGIN 
            ASSERT (
                SELECT COUNT(*)
                FROM $table
                WHERE foo IS NOT NULL
            ) = 3;
        END;
    \$\$
    """
    assert_success
}